var documenterSearchIndex = {"docs":
[{"location":"references.html#References","page":"References","title":"References","text":"","category":"section"},{"location":"references.html#Cited-References","page":"References","title":"Cited References","text":"","category":"section"},{"location":"references.html","page":"References","title":"References","text":"The following references are cited in the documentation.","category":"page"},{"location":"references.html","page":"References","title":"References","text":"N. Kalboussi, A. Rapaport, T. Bayen, N. Ben Amar, F. Ellouze, J. Harmand (2017) Optimal control of a membrane filtration system, IFAC-PapersOnLine\nB. Benyahia, A. Charfi, N. Benamar,  M. Heran, A. Grasmick, B. Cherki, J. Harmand (2013). A simple model of anaerobic membrane bioreactor for control design: coupling the “AM2b” model with a simple membrane fouling dynamics, World Congress on Anerobic Digestion: Recovering (bio) Ressources for the World","category":"page"},{"location":"dev-filtration.html#dev-filtration","page":"Developpers","title":"Filtration.jl private functions","text":"","category":"section"},{"location":"dev-filtration.html","page":"Developpers","title":"Developpers","text":"CollapsedDocStrings = true","category":"page"},{"location":"dev-filtration.html#Index","page":"Developpers","title":"Index","text":"","category":"section"},{"location":"dev-filtration.html","page":"Developpers","title":"Developpers","text":"Pages   = [\"dev-filtration.md\"]\nModules = [Filtration]\nOrder   = [:type, :module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-filtration.html#Documentation","page":"Developpers","title":"Documentation","text":"","category":"section"},{"location":"dev-filtration.html","page":"Developpers","title":"Developpers","text":"Modules = [Filtration]\nOrder   = [:type, :module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"index.html#Filtration-Package","page":"Introduction","title":"Filtration Package","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Documentation for Filtration.","category":"page"},{"location":"index.html#Dependencies","page":"Introduction","title":"Dependencies","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"All the numerical simulations to generate this documentation are performed with the following packages.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.status()","category":"page"},{"location":"api-filtration.html#Filtration.jl-API","page":"API","title":"Filtration.jl API","text":"","category":"section"},{"location":"api-filtration.html","page":"API","title":"API","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-filtration.html","page":"API","title":"API","text":"For the developers, here are the private methods.","category":"page"},{"location":"api-filtration.html#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api-filtration.html","page":"API","title":"API","text":"Pages   = [\"api-filtration.md\"]\nModules = [Filtration]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-filtration.html#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api-filtration.html","page":"API","title":"API","text":"Modules = [Filtration]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-filtration.html#Filtration.Filtration","page":"API","title":"Filtration.Filtration","text":"Filtration module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDocStringExtensions\nForwardDiff\nLaTeXStrings\nNemo\nPlots\nRoots\nSymbolics\n\nList of all the exported names:\n\nMembraneFiltrationModel\nget_psi\nget_root\nget_roots_symbolic_algebraic_fraction\nisKfunction\nisLfunction\nismonotonic\n\n\n\n\n\n","category":"module"},{"location":"api-filtration.html#Filtration.MembraneFiltrationModel","page":"API","title":"Filtration.MembraneFiltrationModel","text":"A membrane filtration model.\n\nContains:\n\na L-function f₁\na K-function f₂\na L-function g\nthe function f₊\nthe function f₋\na function which describes the dynamic of the state (x,u) -> f(x,u)\na function which describes the dynamic of the cost (x,u) -> f⁰(x,u)\n\nConstructor\n\nA membrane filtration model can be constructed using the following code:\n\nMembraneFiltrationModel(f₁::Function, f₂::Function, g::Function)\n\nNote that respectively f_1, g and f₂ are tested to be L-functions and K-functions.\n\nArguments\n\nf₁ : a L-function\nf₂ : a K-function\ng : a L-function\n\nReturns\n\na MembraneFiltrationModel\n\n\n\n\n\n","category":"type"},{"location":"api-filtration.html#Filtration.get_psi-Tuple{MembraneFiltrationModel}","page":"API","title":"Filtration.get_psi","text":"get_psi(\n    model::MembraneFiltrationModel\n) -> Filtration.var\"#ψ#10\"{Filtration.var\"#dg#9\"{var\"#s182\"}, Filtration.var\"#df₋#8\"{var\"#s1821\"}, Filtration.var\"#df₊#7\"{var\"#s1822\"}, <:Function, <:Function, <:Function} where {var\"#s182\"<:Function, var\"#s1821\"<:Function, var\"#s1822\"<:Function}\n\n\nConstruct the function ψ by using ForwardDiff.\n\nArguments\n\nmodel : a MembraneFiltrationModel\n\nReturns\n\nψ : the function ψ\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.get_root","page":"API","title":"Filtration.get_root","text":"get_root(model::MembraneFiltrationModel) -> Any\nget_root(model::MembraneFiltrationModel, x₀::Real) -> Any\n\n\nCompute a root of the function ψ by using ForwardDiff.\n\nnote: Note\nThis function return a root of ψ.  If ψ have multiple roots, it may not return the desired one.\n\nArguments\n\nmodel : a MembraneFiltrationModel\nx₀ : the initial guess, initialized to 0.5\n\nReturns\n\nroots : a root of ψ\n\n\n\n\n\n","category":"function"},{"location":"api-filtration.html#Filtration.get_roots_symbolic_algebraic_fraction-Tuple{MembraneFiltrationModel}","page":"API","title":"Filtration.get_roots_symbolic_algebraic_fraction","text":"get_roots_symbolic_algebraic_fraction(\n    model::MembraneFiltrationModel\n) -> Tuple{Any, Any}\n\n\nCompute the positive roots of the function ψ and its derivative by using Symbolics.  This function works only if the function ψ is an algebraic fraction.\n\nnote: Note\nThis function may be long to compute due to the use of Symbolics.  However, if it compute, it assure that all positive roots of ψ are given. If ψ have only one positive root, use get_roots instead.\n\nArguments\n\nmodel : a MembraneFiltrationModel\n\nReturns\n\nroots : the positive roots of ψ\nDψ : the derivative of ψ at the roots\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.isKfunction-Tuple{Function}","page":"API","title":"Filtration.isKfunction","text":"isKfunction(f::Function; start, stop, N, ε) -> Bool\n\n\nCheck if a function is a K-function.\n\nArguments\n\nf : a function\nstart : the start of the domain, initialized to 0\nstop : the end of the domain, initialized to 100\nN : the number of points, initialized to 100\nε : the precision, initialized to 10^-9\n\nReturns\n\na boolean\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.isLfunction-Tuple{Function}","page":"API","title":"Filtration.isLfunction","text":"isLfunction(f::Function; start, stop, N, ε) -> Bool\n\n\nCheck if a function is a L-function.\n\nArguments\n\nf : a function\nstart : the start of the domain, initialized to 0\nstop : the end of the domain, initialized to 100\nN : the number of points, initialized to 100\nε : the precision, initialized to 10^-9\n\nReturns\n\na boolean\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.ismonotonic","page":"API","title":"Filtration.ismonotonic","text":"ismonotonic(V::AbstractVector) -> Bool\nismonotonic(V::AbstractVector, cmp) -> Bool\n\n\nCheck if a vector is monotonic, with respect to a given comparison operator.\n\nArguments\n\nV : a vector\ncmp : a comparison operator, initialized to >\n\nReturns\n\na boolean\n\n\n\n\n\n","category":"function"},{"location":"basic-example.html#Membrane-Filtration-:-Direct-solve","page":"Basic Example","title":"Membrane Filtration : Direct solve","text":"","category":"section"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"Let us consider the membrane filtration process where the goal is to maximize the water net production ","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"    max_x(cdot) u(cdot) int_0^T u(t) gbig( m(t) big) mathrm dt ","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"where the control u(cdot) in mathrm L^infty(0T mathbb R) corresponds to the filtration mode (1 during filtration and -1 during backwash) and the state m (cdot) in mathrmAC(0 T mathbb R) is the mass of the cake layer formed during the water filtration. The dynamic of this state is given by ","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"    dot m(t) = frac1 + u(t)2 f_1(m(t)) - frac1 - u(t)2 f_2(m(t))","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"with the initial condition m(0) = m_0. ","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"Based on [Kalboussi et al., 2018], we assume that f_1 and g are smooth mathcal L-function, and that f_2 is a smooth mathcal K function. ","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"First, we need to import the Filtration.jl to define this Optimal Control Problem, to give it to OptimalControl.jl package and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"using Filtration\nusing CTBase\nusing OptimalControl\nusing Plots\nusing MadNLP","category":"page"},{"location":"basic-example.html#Model-definition","page":"Basic Example","title":"Model definition","text":"","category":"section"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"In this example, these functions are defined by using the [Benyahia et al.] model : ","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"f_1(m) = fracbe+m quad f_2(m) = am quad f_3(m) = frac1e+m ","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"where a, b and e are positive numbers. The problem is simply defined, thanks to MembraneFiltrationModel.","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"# Benyahia & al. model\na = 1; b = 1; e = 1;\nf₁ = m ->  b ./ (e .+ m)\nf₂ = m -> a .* m\ng  = m -> 1 ./ (e .+ m)\nmodel = MembraneFiltrationModel(f₁, f₂, g);","category":"page"},{"location":"basic-example.html#Verification-of-hypotheses","page":"Basic Example","title":"Verification of hypotheses","text":"","category":"section"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"With this model, we know that the function psi defined by ","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"psi(m) = g(m)bigf_-(m) f_+(m) - f_-(m) f_+(m)big + g(m) f_+(m) f_-(m)","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"have an unique positive root, denoted bar m, where function f_+ and f_- are given by ","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"f_+(m) = fracf_1(m) + f_2(m)2 quad f_-(m) = fracf_1(m) -f_2(m)2 cdot","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"For more information about why this property is needed, please refer to [Kalboussi et al., 2018]. However, we can take a look on this function psi. ","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"ψ = get_psi(model)\nroot = get_root(model)\nplot(range(0,10, 100), ψ, label = \"ψ\")\nscatter!([root], [ψ(root)], label = \"zero of ψ\")","category":"page"},{"location":"basic-example.html#Direct-Solve","page":"Basic Example","title":"Direct Solve","text":"","category":"section"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"We can solve the optimal control problem by derect method, thanks to the OptimalControl.jl package.","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"t0 = 0; m0 = 1; tf = 10;                # initial and final time and state\n@def ocp begin                          # problem definition\n    t ∈ [ t0, tf ], time\n    m ∈ R, state\n    u ∈ R, control\n    -1 ≤ u(t) ≤ 1\n    m(t0) == m0\n    ṁ(t) == model.state_dynamic(m(t),u(t))\n    ∫( model.cost_dynamic(m(t),u(t))) → max\nend\nsol = OptimalControl.solve(ocp, :madnlp)\nplot(sol)","category":"page"}]
}
