var documenterSearchIndex = {"docs":
[{"location":"references.html#References","page":"References","title":"References","text":"","category":"section"},{"location":"references.html#Cited-References","page":"References","title":"Cited References","text":"","category":"section"},{"location":"references.html","page":"References","title":"References","text":"The following references are cited in the documentation.","category":"page"},{"location":"references.html","page":"References","title":"References","text":"N. Kalboussi, A. Rapaport, T. Bayen, N. Ben Amar, F. Ellouze, J. Harmand (2017) Optimal control of a membrane filtration system, IFAC-PapersOnLine","category":"page"},{"location":"dev-filtration.html#dev-filtration","page":"Developpers","title":"Filtration.jl private functions","text":"","category":"section"},{"location":"dev-filtration.html","page":"Developpers","title":"Developpers","text":"CollapsedDocStrings = true","category":"page"},{"location":"dev-filtration.html#Index","page":"Developpers","title":"Index","text":"","category":"section"},{"location":"dev-filtration.html","page":"Developpers","title":"Developpers","text":"Pages   = [\"dev-filtration.md\"]\nModules = [Filtration]\nOrder   = [:type, :module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-filtration.html#Documentation","page":"Developpers","title":"Documentation","text":"","category":"section"},{"location":"dev-filtration.html","page":"Developpers","title":"Developpers","text":"Modules = [Filtration]\nOrder   = [:type, :module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"index.html#Filtration-Package","page":"Introduction","title":"Filtration Package","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Documentation for Filtration.","category":"page"},{"location":"index.html#Dependencies","page":"Introduction","title":"Dependencies","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"All the numerical simulations to generate this documentation are performed with the following packages.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.status()","category":"page"},{"location":"api-filtration.html#Filtration.jl-API","page":"API","title":"Filtration.jl API","text":"","category":"section"},{"location":"api-filtration.html","page":"API","title":"API","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-filtration.html","page":"API","title":"API","text":"For the developers, here are the private methods.","category":"page"},{"location":"api-filtration.html#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api-filtration.html","page":"API","title":"API","text":"Pages   = [\"api-filtration.md\"]\nModules = [Filtration]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-filtration.html#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api-filtration.html","page":"API","title":"API","text":"Modules = [Filtration]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-filtration.html#Filtration.Filtration","page":"API","title":"Filtration.Filtration","text":"Filtration module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDocStringExtensions\nForwardDiff\nLaTeXStrings\nNemo\nPlots\nRoots\nSymbolics\n\nList of all the exported names:\n\nget_root\nget_roots_symbolic_algebraic_fraction\nget_η\nisKfunction\nisLfunction\nismonotonic\nmembrane_filtration_model\n\n\n\n\n\n","category":"module"},{"location":"api-filtration.html#Filtration.membrane_filtration_model","page":"API","title":"Filtration.membrane_filtration_model","text":"A membrane filtration model.\n\nContains:\n\na L-function f₁\na K-function f₂\na L-function g\nthe function f₊\nthe function f₋\na function which describes the dynamic of the state (x,u) -> f(x,u)\na function which describes the dynamic of the cost (x,u) -> f⁰(x,u)\n\nConstructor\n\nA membrane filtration model can be constructed using the following code:\n\nmembrane_filtration_model(f₁::Function, f₂::Function, g::Function)\n\nNote that respectively f_1, g and f₂ are tested to be L-functions and K-functions.\n\nArguments\n\nf₁ : a L-function\nf₂ : a K-function\ng : a L-function\n\nReturns\n\na membrane filtration model\n\n\n\n\n\n","category":"type"},{"location":"api-filtration.html#Filtration.get_root","page":"API","title":"Filtration.get_root","text":"get_root(model::membrane_filtration_model) -> Any\nget_root(model::membrane_filtration_model, x₀::Real) -> Any\n\n\nCompute a root of the function ν by using ForwardDiff.\n\nnote: Note\nThis function return a root of ν.  If ν have multiple roots, it may not return the desired one.\n\nArguments\n\nmodel : a membrane filtration model\nx₀ : the initial guess, initialized to 0.5\n\nReturns\n\nroots : a root of ν\n\n\n\n\n\n","category":"function"},{"location":"api-filtration.html#Filtration.get_roots_symbolic_algebraic_fraction-Tuple{membrane_filtration_model}","page":"API","title":"Filtration.get_roots_symbolic_algebraic_fraction","text":"get_roots_symbolic_algebraic_fraction(\n    model::membrane_filtration_model\n) -> Tuple{Any, Any}\n\n\nCompute the positive roots of the function ν and its derivative by using Symbolics.  This function works only if the function ν is an algebraic fraction.\n\nnote: Note\nThis function may be long to compute due to the use of Symbolics.  However, if it compute, it assure that all positive roots of ν are given. If ν have only one positive root, use get_roots instead.\n\nArguments\n\nmodel : a membrane filtration model\n\nReturns\n\nroots : the positive roots of ν\nDν : the derivative of ν at the roots\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.get_η-Tuple{membrane_filtration_model}","page":"API","title":"Filtration.get_η","text":"get_η(\n    model::membrane_filtration_model\n) -> Filtration.var\"#ν#14\"{Filtration.var\"#dg#13\"{var\"#s182\"}, Filtration.var\"#df₋#12\"{var\"#s1821\"}, Filtration.var\"#df₊#11\"{var\"#s1822\"}, <:Function, <:Function, <:Function} where {var\"#s182\"<:Function, var\"#s1821\"<:Function, var\"#s1822\"<:Function}\n\n\nConstruct the function ν by using ForwardDiff.\n\nArguments\n\nmodel : a membrane filtration model\n\nReturns\n\nν : the function ν\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.isKfunction-Tuple{Function}","page":"API","title":"Filtration.isKfunction","text":"isKfunction(f::Function; start, stop, N, ε) -> Bool\n\n\nCheck if a function is a K-function.\n\nArguments\n\nf : a function\nstart : the start of the domain, initialized to 0\nstop : the end of the domain, initialized to 100\nN : the number of points, initialized to 100\nε : the precision, initialized to 10^-9\n\nReturns\n\na boolean\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.isLfunction-Tuple{Function}","page":"API","title":"Filtration.isLfunction","text":"isLfunction(f::Function; start, stop, N, ε) -> Bool\n\n\nCheck if a function is a L-function.\n\nArguments\n\nf : a function\nstart : the start of the domain, initialized to 0\nstop : the end of the domain, initialized to 100\nN : the number of points, initialized to 100\nε : the precision, initialized to 10^-9\n\nReturns\n\na boolean\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.ismonotonic","page":"API","title":"Filtration.ismonotonic","text":"ismonotonic(V::AbstractVector) -> Bool\nismonotonic(V::AbstractVector, cmp) -> Bool\n\n\nCheck if a vector is monotonic, with respect to a given comparison operator.\n\nArguments\n\nV : a vector\ncmp : a comparison operator, initialized to >\n\nReturns\n\na boolean\n\n\n\n\n\n","category":"function"}]
}
